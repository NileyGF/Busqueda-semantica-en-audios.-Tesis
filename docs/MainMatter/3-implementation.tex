\chapter{Detalles de implementación}
\label{chap:implementation}

% El sistema de validación de modelos para un VRP específico cuenta con cuatro componentes descritos en el capítulo anterior. En este capítulo se presentan las abstracciones realizadas para llevar a cabo la implementación de cada una de las componentes. Además, se describen los detalles de la implementación realizada en este trabajo. En la sección \ref{sec:def} se describe la manera propuesta para definir un VRP. Posteriormente, en las secciones \ref{sec:highSol}, \ref{sec:lowSol} y \ref{sec:func} se muestran los detalles de implementación de los primeros tres componentes del sistema: el generador de soluciones de alto nivel, el generador de soluciones de bajo nivel y el generador de funciones, respectivamente. Por último, se presenta el pseudocódigo general seguido en la evalución del modelo y la implementación llevada a cabo en el trabajo.

% A continuación se muestra la manera de definir un VRP para poder evaluar el modelo correspondiente.

% \section{Definición de un VRP} \label{sec:def}
% Las características abstractas se definieron, en la sección \ref{sec:inputs}, como la manera propuesta en este trabajo para describir un problema de enrutamiento de vehículos. Cada una de las características se representa mediante una clase sin campos y que no hereda de ninguna otra.

% A modo de ejemplo, se definen las clases {\tt visit-client-at-least-once}, {\tt visit-client-at-most-once}, {\tt dont-overload-vehicles} y {\tt begin-end-in-\\depot}. Con estas clases creadas es posible definir el CVRP como una clase que hereda de todas las características que lo definen. El código \ref{alg:cvrp} muestra lo anterior.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defclass cvrp (dont-overload-vehicles
%                 begin-end-in-depot
%                 visit-client-at-most-once
%                 visit-client-at-least-once) ())
% \end{lstlisting}
% 	\caption{Definición del CVRP a partir de las características abstractas.}  \label{alg:cvrp}
% \end{figure}

% Para simular los elementos del conjunto $B_A$ mostrado en la sección \ref{sec:inputs} se define, para cada característica abstracta, al menos una {\it característica opuesta} que represente el comportamiento contrario a dicha característica abstracta. Por ejemplo, para las características mostradas con anterioridad, se implementan las clases {\tt dont-visit-all-clients}, {\tt visit-client-more-\\than-once}, {\tt overload-vehicles} y {\tt begin-end-anywhere}.

% Una característica abstracta puede tener varias características opuestas que definan distintas maneras de incumplirlas. Por ejemplo, para no satisfacer la característica de comenzar y terminar una ruta en el depósito central, se puede no empezar en el depósito, no terminar en él o ambas opciones. Estos comportamientos pueden ser modelados, cada uno, por distintas clases.

% Para construir el conjunto $B_A$, es necesario conocer para cada característica abstracta, las características opuestas que le corresponden. Para ello se tiene la función {\tt opposite-characteristics} que dada una característica abstracta, devuelve el conjunto de características opuestas. Por ejemplo, cuando se evalúa esta función con el nombre de la clase {\tt dont-overload-\\vehicles}, se obtendría como resultado el nombre de la clase {\tt overload-ve-\\hicles}.

% Una vez definido el problema para el cual se desea validar un modelo y el conjunto de características opuestas, es posible generar las soluciones de alto nivel como muestra la siguiente sección.

% \section{Generación de soluciones de alto nivel} \label{sec:highSol}
% El generador de soluciones de alto nivel crea soluciones a partir de un conjunto de requerimientos. Cada elemento de este conjunto es una combinación de características abstractas y opuestas que representa un elemento de $B_A$. Para generar las soluciones de manera que cumplan cada una de las características, se define una función genérica {\tt generate-solution}. Esta función recibe el requerimiento y una solución e instancia de problema vacías. Por cada característica presente en el requerimiento se modifica el elemento en la solución o el problema a la que esa característica afecte. De esta manera, una vez se termine de recorrer todos los elementos que conforman el requerimiento se tendrá una solución y un problema que lo satisfagan.

% Por ejemplo, la clase {\tt cvrp}, mostrada en \ref{alg:cvrp}, define un requerimiento: el de las soluciones factibles para el CVRP. Con esta clase, la función {\tt generate-solution} recorrería cada característica en {\it determinado orden}. Supongamos que para ese ejemplo el orden establecido es de la característica final a la primera. En este caso, {\tt visit-client-at-least-once} añade el conjunto de clientes al problema y luego crea rutas en la solución donde todos los clientes son visitados al menos una vez. Luego, {\tt visit-client-at-\\most-once} verifica que en el conjunto de rutas ya creado se visite una única vez a cada cliente y, de no ser así, elimine a los clientes repetidos. Con la característica {\tt begin-end-in-depot} se añade el depósito al inicio y al final de cada una de las rutas. Finalmente, {\tt dont-overload-vehicles} define una capacidad en el problema que impida que las rutas ya definidas sean visitadas por vehículos sobrecargados, por ejemplo, tomando como la capacidad la suma de las demandas de todos los clientes.

% A partir del ejemplo se puede notar que el orden en el que se definan las características es importante a la hora de construir las soluciones. Si se hubiera analizado primero la característica {\tt dont-overload-vehicles}, esta, además de trazar una estrategia para definir la capacidad de los vehículos, tendría que construir el conjunto de clientes y las rutas para garantizar que se cumpla la restricción de capacidad. Esto complicaría la construcción de la solución en las características siguientes pues habría que verificar un mayor número de condiciones. Por ejemplo, al analizar {\tt dont-overload-vehi-\\cles} primero, {\tt visit-client-at-most-once} debe controlar que las rutas creadas visiten a lo sumo una vez a cada cliente y, de no cumplirse, modificarlas para que satisfagan esta restricción. De suceder esto, las restricciones de capacidad tienen que ser verificadas de nuevo.

% La decisión del orden correcto para definir las características de un problema depende de la implementación de la función genérica {\tt generate-so-\\lution} para cada característica. En el caso de este trabajo, el orden correcto para el CVRP es el definido en el código \ref{alg:cvrp}. A continuación se presentan los detalles de la implementación propuesta para este trabajo.

% \subsection{Implementación de la función {\tt generate-solution}}
% La implementación de la función {\tt generate-solution} se realizó haciendo uso de las funcionalidades del lenguaje Common Lisp descritas en la sección \ref{sec:lisp}. La definición de la función genérica {\tt generate-solution} se muestra en la figura \ref{alg:gsGeneric}.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defgeneric generate-solution (condition
%                                solution
%                                problem
%                                log))
% \end{lstlisting}
% 	\caption{Definición de la función genérica {\tt generate-solution}.}  \label{alg:gsGeneric}
% \end{figure}

% La función recibe una solución ({\tt solution}) y un problema ({\tt problem}) vacío que se modificarán a medida que se analicen las características definidas en la condición ({\tt condition}). En cada una de las implementaciones de la función genérica, el parámetro {\tt condition} se especializa en una característica distinta (ya sea abstracta u opuesta). En el parámetro {\tt log} se registran los pasos llevados a cabo para construir la solución.

% La manera de definir una condición es a través de una clase que herede de las características que debe cumplir la solución y el problema generado como se observa en la figura \ref{alg:cvrp}. Esta forma permite que al especificar {\tt :after} luego de la definición de los métodos para cada característica, se invoquen todas las implementaciones de la función genérica {\tt generate-function}. Como los métodos {\tt :after} se ejecutan de menos a más específicos, el orden de ejecución sería de la última característica a la primera. En el caso del ejemplo \ref{alg:cvrp} se ejecuta en el orden inverso de la lista de los ancestros, es decir, primero el método donde {\tt condition} se haya especializado en {\tt visit-client-at-least-once} y por último el correspondiente a la clase {\tt dont-overload-vehicles}.

% Por ejemplo, la definición del método para generar soluciones que cumplan con la característica {\tt visit-client-at-least-once} se muestra en la figura \ref{alg:gsMethod:vcalo}. En el cuerpo de dicho método se generan una cantidad aleatoria de clientes y se selecciona el número de rutas $K$. Para construir dichas rutas se divide una permutación del conjunto de clientes en $K$ conjuntos que representan las rutas. Las demandas de cada cliente son también elegidas de manera aleatoria. De esta forma se garantiza que cada cliente sea visitado al menos una vez.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defgeneric generate-solution :after
%             ((condition visit-client-at-least-once)
%              solution
%              (problem cvrp-problem)
%              log)
%  ;; generar las soluciones
%  )
% \end{lstlisting}
% 	\caption{Definición del método {\tt generate-solution} para la característica {\tt visit-client-at-least-once}.}  \label{alg:gsMethod:vcalo}
% \end{figure}

% Como la definición de un método primario es obligatoria, se implementó uno con el cuerpo vacío.

% Una vez construidas las soluciones de alto nivel y las instancias del problema, es posible generar las soluciones de bajo nivel. La sección siguiente describe los elementos necesarios para implementar este componente.

% \section{Generación de soluciones de bajo nivel} \label{sec:lowSol}
% El generador de soluciones de bajo nivel transforma las soluciones de alto nivel en conjuntos de variables, parámetros y conjuntos presentes en el modelo.

% Para construir el conjunto de variables es necesario conocer, además de la solución de alto nivel, el tipo de formulación con la que se modeló el problema. De esta manera, cuando se valide el modelo por flujo de mercancías del CVRP se podrán generar las variables correctas $x_{ij}$ y $y_{ij}$. Sin embargo, en la sección \ref{subsec:modelTypes} se presentaron formulaciones que, en dependencia del problema, podían agregar nuevas variables. Por esta razón, cuando se quiera validar un modelo es necesario implementar la transformación de la solución a las variables involucradas en ese modelo en específico.

% El conjunto de parámetros y conjuntos es dependiente del problema. Además, un mismo problema puede ser modelado utilizando conjuntos de parámetros distintos. Al igual que con la generación del conjunto de variables, los conjuntos de parámetros y de conjuntos debe implementarse para cada modelo específico. Con esto se garantiza que la transformación genere exactamente los mismos conjuntos que aparecen en el modelo.


% La generación de las soluciones de bajo nivel puede realizarse en una misma función {\tt generate-low-level-solution}. Sin embargo, la implementación propuesta en este trabajo cuenta con dos funciones {\tt generate-varia-\\bles} y {\tt generate-param-set-values} donde se generan el conjunto de variables y el conjunto de parámetros y conjuntos, respectivamente. A continuación se muestran los detalles de la implementación propuesta para estas funciones.

% \subsection{Implementación de la función {\tt generate-variables}}
% La generación del conjunto de variables se realiza a través de la función genérica {\tt generate-variables} definida en la figura \ref{alg:gvGeneric}

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defgeneric generate-variables (solution
%                                 problem
%                                 model-type))
% \end{lstlisting}
% 	\caption{Definición de la función genérica {\tt generate-variables}.}  \label{alg:gvGeneric}
% \end{figure}

% Las entradas {\tt solution} y {\tt problem} representan la solución y el problema creados en el generador de soluciones de alto nivel.

% El tipo de modelo ({\tt model-type}) se representa mediante una clase para cada formulación posible. Por esta razón, se implementaron las clases {\tt commodity-flow}, {\tt two-index-vehicle-flow} y {\tt three-index-vehicle-flow} para las formulaciones por flujo de mercancías, flujo de vehículos de dos índices y flujo de vehículos de tres índices, respectivamente. La entrada {\tt model-type} se especializa en cada una de las clases mencionadas.

% Esta función asigna los valores correctos para cada una de las variables presentes en el problema a partir de la solución ya generada.

% Por ejemplo, para el modelo por flujo de mercancía del CVRP se conoce que son necesarias las variables $x_{ij}$ y $y_{ij}$ que representan el paso y la capacidad residual de un vehículo que va del nodo $i$ al nodo $j$, respectivamente. En este caso, la función {\tt generate-variables} recorre las rutas definidas en la solución y le asigna el valor 1 a cada variable $x_{ij}$ si se visita al cliente $j$ después del cliente $i$. Además, a la capacidad $C$ del vehículo le resta la demanda del cliente $i$ cuando se pasa al cliente $j$ y le asigna este valor a la variable $y_{ij}$. A $y_{ji}$ le asigna el resultado de la operación $C - y_{ij}$. Para la solución \ref{fig:probSolEj} de la página \pageref{fig:varEj}, las variables generadas se muestran en la figura \ref{fig:varEj} que aparece en la misma página. El encabezado que tendría la implementación de la función genérica {\tt generate-variables} para el ejemplo se muestra en la figura \ref{alg:gvMethod:cf}.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defgeneric generate-variables
%             (solution
%              (problem cvrp-problem)
%              (model-type commodity-flow))
%  ;; generar variables
%  )
% \end{lstlisting}
% 	\caption{Encabezado del método {\tt generate-variables} para el modelo por flujo de mercancías del CVRP.}  \label{alg:gvMethod:cf}
% \end{figure}

% \subsection{Implementación de la función {\tt generate-param-set-values}} \label{subsec:gpsv}
% Los conjuntos de parámetros y conjuntos solo depende de la solución y problema creados en el generador de soluciones de alto nivel. Por esta razón, la función genérica {\tt generate-param-set-values} definida en la figura \ref{alg:gpsGeneric} solo tiene dos entradas: {\tt solution} y {\tt problem}. La primera representa la solución y la segunda, la instancia de problema.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defgeneric generate-param-set-values (solution
%                                        problem))
% \end{lstlisting}
% 	\caption{Definición de la función genérica {\tt generate-param-set-values}.} \label{alg:gpsGeneric}
% \end{figure}

% Con el conjunto de parámetros y conjuntos generados, es posible definir las funciones que representan cada una de las restricciones del problema y en las que se evaluará el conjunto de variables. En la siguiente sección se muestran los elementos tenidos en cuenta para la implementación del generador de funciones.

% Para el CVRP se necesitan los parámetros $C$, $d$, $K$ que representan la capacidad de los vehículos, la demanda de cada cliente y la cantidad de vehículos, respectivamente. Además, se tiene el conjunto $V$ de clientes. La función {\tt generate-param-set-values} asigna los valores adecuados para cada uno de estos parámetros y conjuntos a partir de la solución y el problema. Para el ejemplo de solución y problema de la figura \ref{fig:probSolEj2} se generarían los conjuntos mostrados en la figura \ref{fig:paramSetEj}.

% \begin{figure}[h!]
% 	\begin{minipage}{0.45\textwidth}
% 		{\bf Problema}
		
% 		{\tt cantidad de clientes: 3\\capacidad: 3\\depósito: 0\\demandas: $\{1, 2, 1\}$}
% 	\end{minipage}
% 	\hfill
% 	\begin{minipage}{0.45\textwidth}
% 		{\bf Solución}
		
% 		{\tt rutas: $\{0, 1, 2, 0\}$ y $\{0, 3, 0\}$}
% 	\end{minipage}
% 	\caption{Problema y solución generada para el requerimiento $(\{1, 2, 3\}, \{\})$.} \label{fig:probSolEj2}
% \end{figure}

% \begin{figure}[h!]
% 	\centering
% 	\begin{minipage}{0.45\textwidth}
% 		\begin{center}
% 			$n = 3$
			
% 			$K = 2$
			
% 			$C = 3$
			
% 			$d = (1,\ 2,\ 3)$
% 		\end{center}
% 	\end{minipage}
% 	\hfill \begin{minipage}{0.45\textwidth}
% 		$V = \{0,\ 1,\ 2,\ 3,\ 4\}$
% 	\end{minipage}
% 	\caption{Conjunto de parámetros $p_i$ (a la izquierda) y conjunto de instancias de los conjuntos $c_i$ (a la derecha) para la solución y problema de la figura \ref{fig:probSolEj2}}
% 	\label{fig:paramSetEj}
% \end{figure}

% \section{Generación de funciones} \label{sec:func}
% La generación de funciones se realiza utilizando el Árbol de Sintaxis Abstracta (AST)\footnote{Los Árboles de Sintaxis Abstracta (AST) representan jerárquicamente, mediante un árbol, la estructura sintáctica abstracta o simplificada de un programa escrito en un lenguaje de programación.} que se obtiene a partir del modelo descrito en algún AML. En este trabajo se usa LMML. Con en el AST se puede organizar las operaciones que se realizan en cada restricción.

% Por ejemplo, si se tiene la restricción $s.a\ x_{ij} \geq 0 \ \ \forall i, j \in V$, se obtiene el AST mostrado en la figura \ref{fig:ast}.

% \begin{figure}[h!]
% 	\centering
% 	\includegraphics[width=0.75\textwidth]{MainMatter/images/ast.png}
% 	\caption{AST obtenido a partir de la restricción $s.a\ x_{ij} \geq 0 \ \ \forall i, j \in V$.} \label{fig:ast}
%       \end{figure}

% A partir del AST se pueden realizar recorridos donde, en dependencia del nodo en el que se encuentre, se genere el fragmento de código correspondiente a la función. Para el ejemplo de la figura \ref{fig:ast} se puede realizar un recorrido donde, cuando se encuentre el nodo $s.a.$ se cree el encabezamiento de la función que se quiere generar. A continuación, se puede recorrer cada una de las ramas de izquierda a derecha para generar el código de la operación que se debe realizar y de los índices. Los códigos generados son dependientes del lenguaje en el que se desee realizar la validación.

% Como las funciones reciben las variables del modelo como entrada, es necesario conocer previamente qué variables se definen en él. Para ello se realiza un recorrido por el AST del modelo que reúna todas las variables. Este recorrido se lleva a cabo en la función {\tt collect-variables}.

% Para la transformación de las restricciones se define una función {\tt gene-\\rate-functions} encargada de recorrer el AST del modelo y crear, por cada restricción, una función cuyas entradas sean cada una de las variables del modelo recolectadas previamente. Las funciones, al no recibir los parámetros y conjuntos del modelo, deben sustituir los identificadores de los mismos por los valores correspondientes. Dichos valores se obtienen en el generador de soluciones de bajo nivel.

% El trabajo propone una implementación de las funciones {\tt collect-va-\\riables} y {\tt generate-functions} que hace uso de las funcionalidades de LMML. A continuación se describen los detalles de la implementación de las funciones {\tt collect-variables} y {\tt generate-functions}.

% \subsection{Implementación de la función {\tt collect-variables}}
% LMML estructura el modelo a partir de clases que representan las operaciones que definen las restricciones y función objetivo de un modelo. De esta forma, cuando se escribe un modelo en LMML, la estructura que se obtiene es el AST del mismo.

% El recorrido que permite recolectar todas las variables del modelo se implementa en la función genérica {\tt collect-variables}. La definición de esta se muestra en la figura \ref{alg:cvGeneric}.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defgeneric collect-variables (model-instruction
%                                model))
% \end{lstlisting}
% 	\caption{Definición de la función genérica {\tt collect-variables}.} \label{alg:cvGeneric}
% \end{figure}

% La entrada {\tt model-instruction} se especializa en cada una de las clases que pueden encontrarse en el AST, solo guardando el nombre de las variables definidas cuando se encuentra con el nodo de {\tt variable-declaration}. La función devuelve una lista de los nombres de todas las variables declaradas en el modelo. Con esta lista es posible generar las funciones correspondientes a cada una de las restricciones del modelo como se muestra en la sección siguiente.

% \subsection{Implementación de la función {\tt generate-functions}}
% Para generar las funciones se define la función genérica {\tt generate-\\functions} como se muestra en la figura \ref{alg:gfGeneric}.

% \begin{figure}[h!]
% \begin{lstlisting}
% (defgeneric generate-functions (ast-node
%                                 param-set-values
%                                 variables))
% \end{lstlisting}
% 	\caption{Definición de la función genérica {\tt generate-functions}.} \label{alg:gfGeneric}
% \end{figure}

% La entrada ({\tt ast-node}), que representa el nodo del AST que se esté analizando en el momento, se especializa en las distintas clases definidas en LMML. En cada uno se genera el fragmento de código de Common Lisp que permite obtener funciones evaluables.

% Cuando en el recorrido se encuentre una referencia a un parámetro o conjunto, se verifica que estén en la lista {\tt param-set-values} y se sustituye su nombre por el valor correspondiente. Como puede deducirse, es importante que el nombre con el que se definen los parámetros y conjuntos en el modelo coincida con los nombres recogidos en la lista. Actualmente, esto solo se garantiza mediante la implementación manual de la función {\tt generate-param-set-values} mostrada en la sección \ref{subsec:gpsv}.

% El conjunto de nombres de variables ({\tt variables}) se utiliza para definir la entrada de cada función.

% Para el AST visto en la figura \ref{fig:ast}, la función {\tt generate-functions} generaría la función matemática siguiente:

% $$
% f(x) = \left\{\begin{array}{cl}
% 				1 & si\ x_{ij} \geq 0  \ \ \forall i, j \in V\\
% 				0 & en\ otro\ caso
% 			  \end{array}\right.
% $$

% Con todas estas funciones definidas, es posible pasar a la evaluación del modelo. La siguiente sección describe el algoritmo con el que evaluar un modelo de entrada para un VRP específico.

% \section{Evaluación del modelo} \label{sec:eval}
% En la evaluación del modelo se combinan todas las funciones vistas hasta el momento en las secciones anteriores y se implementa la estrategia descrita en el capítulo \ref{chap:system} como se muestra en el pseudocódigo \ref{alg:mePseudocode}.

% \begin{algorithm}[htb]
% 	\caption{Algoritmo propuesto para la validación automática de un modelo para VRP}\label{alg:mePseudocode}
% 	\SetAlgoLined
% 	\KwData{Características abstractas $A$ del VRP y modelo $M$}
% 	\KwResult{Verdadero si el modelo parece correcto; falso si no}
% 	\LinesNumbered
% 	\SetAlgoVlined
% 	$B_A = \{(C_i, C_i^c) | C_i \subseteq A\ \ \forall i = \overline{1, 2^{|A|}}\}$\;
% 	\For{$(C_i, C_i^c) \in B_A$}{
% 		\For{$k = 1, 2, \dots, K$}{
% 			$S_{ik}, P_{ik} = generate\_solution(C_i, C_i^c)$\;
% 			$v_{ik}, p_{ik}, c_{ik} = generate\_low\_level\_solution(S_{ik}, P_{ik})$\;
% 			$v_{name} = collect\_variables(M)$\;
% 			$f_{ik} = generate\_functions(M, p_{ik}, c_{ik}, v_{name})$\;
% 			\If{$f(v_{ik})\ \ \forall f \in f_{ik}$}{
% 				$continue$\;}
% 			\Else{\Return Falso, ($S_{ik}, P_{ik}$)\;}
% 		}
% 	}
% 	\Return Verdadero\;
% \end{algorithm}

% En este trabajo se implementó la evaluación del modelo en la función {\tt evaluate-model} cuya definición se muestra en la figura \ref{alg:emFunction}.

% \begin{figure}[h!]
% \begin{lstlisting}
% (defgeneric evaluate-model (problem
%                             model))
% \end{lstlisting}
% 	\caption{Definición de la función {\tt evaluate-model}.} \label{alg:emFunction}
% \end{figure}

% La entrada {\tt problem} representa el problema descrito mediante las clases que representan sus características abstractas, mientras que {\tt model} es la especificación del modelo que se debe evaluar, escrito en LMML. El problema se debe definir como se muestra en el código \ref{alg:cvrp}.

% Además de conocer los detalles de la implementación del sistema propuesto en este trabajo, es importante presentar la manera en la que se pueden incorporar nuevos problemas y modelos. En la próxima sección se ilustran los recursos del sistema para realizarlo.

% \section{Extensibilidad}

% En esta tesis solo se implementó la validación del modelo de flujo de mercancías del CVRP. Sin embargo, cuenta con los recursos necesarios para que pueda ser extendido a otros problemas y modelos, como se presenta en esta sección. Inicialmente se ilustrará la manera de definir nuevos problemas y, posteriormente, la manera de incorporar nuevos modelos.

% \subsection{Definición de nuevos problemas}
% En este trabajo se propuso la definición de un VRP a partir de un conjunto de características abstractas. Actualmente, el sistema cuenta con la implementación de las características del CVRP. Sin embargo, es posible la incorporación de nuevos problemas.

% Como se comentó en la sección \ref{sec:def}, cada característica abstracta de un problema se representa mediante una clase que no cuenta con campos ni ancestros. Para cada característica debe existir, al menos, la implementación de una característica opuesta.

% Por ejemplo, si se quisiera añadir la característica del VRPB de visitar a todos los clientes cuya demanda debe ser satisfecha antes de los clientes a los que se le debe recoger una cantidad, entonces es necesario crear la clase mostrada en el código \ref{alg:vrpbCA}.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defclass linehaul-before-backhaul () ())
% \end{lstlisting}
% 	\caption{Definición de una nueva característica abstracta para el VRPB.} \label{alg:vrpbCA}
% \end{figure}

% Además, se debe definir al menos una característica opuesta como se ilustra en el código \ref{alg:vrpbCO}.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defclass not-linehaul-before-backhaul () ())
% \end{lstlisting}
% 	\caption{Definición de una nueva característica abstracta para el VRPB.} \label{alg:vrpbCO}
% \end{figure}

% Es importante aclarar que en este, como en muchos otros casos, es posible definir más de una manera de incumplir la característica abstracta y, para ello, pueden crearse varias clases que representen cada uno de esos comportamientos. Por ejemplo, para incumplir la característica definida en \ref{alg:vrpbCA}, puede intercalarse cada tipo de cliente o puede invertirse el orden, es decir, primero los clientes a los que hay que recogerle algún producto y después los clientes a los que hay que llevarle alguna mercancía.

% Para conocer qué características opuestas le corresponden a determinada característica abstracta, es necesario implementar la función {\tt opposite-\\characteristics}.

% Con las características abstractas y opuestas bien definidas, es posible pasar a realizar la generación de las  soluciones e instancias de problemas. Esto se realiza especializando el parámetro {\tt condition} de la función genérica {\tt generate-solution} en la clase correspondiente a la característica que se quiera cumplir (ya sea abstracta u opuesta) y modificando en el cuerpo del método la solución y el problema según sea pertinente.

% Una vez se define una característica y la manera de generar soluciones e instancias de problemas a partir de ella, esta puede ser usada en la definición de cualquier problema cuya solución deba satisfacer dicha característica.

% A continuación se muestra la manera de definir un nuevo modelo.

% \subsection{Definición de nuevos modelos}
% Para definir un nuevo modelo se debe conocer el tipo de formulación que utiliza y las variables, parámetros y conjuntos que relaciona.

% Cada tipo de formulación se define mediante una clase sin campos ni ancestros. Actualmente, el sistema cuenta con la implementación de los tres tipos de modelo presentados en la sección \ref{subsec:modelTypes}.

% Para definir los valores del conjunto de variables a partir de la solución y el problema, se debe especializar el parámetro de {\tt model-type} en la función genérica {\tt generate-variables}. En el cuerpo del método debe implementarse la manera de obtener el conjunto adecuado de variables. Por ejemplo, para el modelo por flujo de vehículos de tres índices del VRPTW, se debe definir la función mostrada en el código \ref{alg:vrptwGV}.

% \begin{figure}[h!] 
% \begin{lstlisting}
% (defmethod generate-variables
%     (solution
%      (problem vrptw-problem)
%      (model-type three-index-vehicle-flow))
%     ;; instrucciones para generar variables
%     )
% \end{lstlisting}
% 	\caption{Definición del método para obtener los valores de las variables $x_{ijk}$ y $w_{ik}$ para el modelo de flujo de vehículos de tres índices del VRPTW.} \label{alg:vrptwGV}
% \end{figure}

% Como el conjunto de parámetros y conjuntos depende del problema y la modelación que se realice, cuando se define un nuevo modelo se debe implementar la función {\tt generate-param-set-values}. En el cuerpo de la misma deben asignarse los valores adecuados para los parámetros y conjuntos del nuevo modelo y problema.

% Al definirse el modelo en LMML, la generación de funciones se realiza de manera completamente automática, por lo que no es necesario realizar ninguna modificación en este componente.

% En este capítulo se describieron los detalles de implementación y la extensibilidad del sistema de validación de modelos para un VRP propuesto. En el próximo capítulo se presentarán los resultados obtenidos cuando se probó la herramienta en el modelo de CVRP por flujo de mercancías definido en Toth y Vigo \cite{toth@vrp}.
